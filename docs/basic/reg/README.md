---
sidebarDepth: 2
title: '正则表达式入门'
tags: 
  - 正则
---
## 入门
本文介绍的大部分正则语法，还试图成为可以在日常工作中使用的正则表达式语法参考手册。

### 正则表达式是什么？
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

## 核心概念
### 元字符
下表包含了常用的元字符以及它们的说明
|  代码   | 说明  |
|  ----  | ----  |
| .  | 匹配除换行符以外的任意字符 |
| \w  | 匹配字母或数字或下划线或汉字 |
| \W | 匹配除了字符、数字、下划线、汉字之外的字符，即[^\w] |
| \s  | 匹配任意的空白符 |
| \S | 匹配非空字符的字符 |
| \d  | 匹配数字 |
| \D  | 匹配非数字字符 |
| \b  | 匹配单词开始或结束 |
| ^  | 匹配字符串的开始 |
| $  | 匹配字符串的结束 |

以下为代码实操：
```js
// 元字符 正则使用的转义字符
// \w === [0-9A-z_]
// \W === [^\w]
var reg = /\wab/g
var str = '234abc-%&'
console.log(str.match(reg)) // [4ab]
// \d === [0-9]
// \D === [^\d]
// \s === [\r\n\t\v\f]      \v是垂直换行 \f是换页符
// \S === [^\s]
var reg = /\sab/g;
var str = '23 ab-$&';
console.log(str.match(reg)) // [ ab]

// \b 单词边界
// \B 非单词边界
var reg = /his\b/g;
var str = 'this a p';
console.log(str.match(reg)) // [his]
```

### 转义字符
转义字符顾名思义就是转换意义的符号，如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\（\就是一个转义符号）。
例如：baidu\.com 匹配baidu.com，以下有更多例子方便大家理解：
```js
var str = "woshi"kkk"pppp"; // 这个样子内外都是双引号，程序会报语法错误，为什么呢？因为"woshi"是一组，"pppp"是一组，而kkk是一个变量，字符串变量字符串中间没有链接符号就会语法错误
// js面对语法的时候先解释的是正常的语法，再输出

// 那我们如果就是想要""当作文本进行输出的话该怎么做？这时候就需要 用到 转义字符了
var str = "woshi\"kkk\"pppp";   // \"就将"变成单纯的字符串了

// 比较常见的转义字符 \n \r \t 但这些转义字符都有特殊的功能所以我们叫它为转义字符特殊功能
// \n 换行
// \r 回车
// \t 制表符 相当于 tab键

// js 不允许字符串换行
var str = 'ajsoidjf
           oajsdofja' //  报错
//那如果 我一定要换行的话我该怎么做？在换行结尾添加转义符号 ，如下
var str = 'ajsoidjf\
           oajsdofja'; // 这样就可以了 ，那这里的转义符号转义的是什么东西呢？是转义字符侯后面的空格（到需要换行的地方位置）       
```

### 重复
下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：
|  代码/语法   | 说明  |
|  ----  | ----  |
| * | 重复零次或更多次 |
| +  | 重复一次或更多次 |
| ？ | 重复零次或一次 |
| {n}  | 重复n次 |
| {n,} | 重复n次到无限次 |
| {n,m}  | 重复n到m次 |

下面是一些使用重复的例子：
```js
//n+ {1, 正无穷} 出现个数1到正无穷
var reg = /\w+/g
var str = "abcd"
console.log(str.match(reg)) // [abcd]
// 正则原则：不回头，贪婪模式

//n* {0, 正无穷} 出现个数0到正无穷
var reg = /\w*/g
var str = "abcd"
console.log(str.match(reg)) // [abcd, ''] 第二个空是d后面的空
var reg2 = /\d*/g
console.log(str.match(reg2)) // ['', '', '', '']
// 总结 字符串从左到右，依次先匹配多，在匹配少，如果一旦匹配上就不会有匹配
// 贪婪匹配原则：能匹配多个，绝不匹配少个

//n? {0, 1} 出现0 或者 1次
var reg = /\w?/g
var str = 'abcd'
console.log(str.match(reg)) // [a, b, c, d, '']

// 区间
// n{x, y}    n{1,} === n+     n{0,} === n*    n{0,1} === n?
var reg = /\w{1,2}/ // 注意 则这里的区间里面不要习惯性的写空格，如果第二位不填就是到正无穷比如{2,}就表示2到正无穷
var str = 'abcd'
console.log(str.match(reg)) // [ab, cd]
var reg2 = /\w{5,}/
console.log(str.match(reg2)) // null
```

### 字符类
要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。

我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。
以下的例子帮助理解：
```js
var str = '0987jlfajsdfjlasjdlfjalieiie';
reg = /[123456789][123456789][123456789]/g; // 这个的意思是 第一位是0-9 第二位0-9 第三位 0-9
str.match(reg) // [098]    为什么987没有检测出来呢？这边有个注意点，match只会匹配一次，匹配过的字符它不会再返回去匹配了

// problem 1
var reg = /[wx][xy][z]/g;
var str = 'wxyz'
console.log(str.match(reg)) // [xyz]

// problem2 写区间 0-9 A-Z a-z A-z 0-z 0-Z 都是可以的
var str = 'uo8fsdf787Gahfksd';
var reg = /[0-9][A-Z][a-z]/g; // 如果需要第一位为数字或小写字母的话 可以这么写 /[0-9a-z]/
console.log(str.match(reg)) // [7Ga]

// 表达式里面写^是代表非的意思 比如 /[^0]/ 表示第一位非0
```


